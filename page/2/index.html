<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="小花儿的技术博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="小花儿的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yangs">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>小花儿的技术博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">小花儿的技术博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yangs"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yangs</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/Java-AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/07/Java-AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java-AbstractQueuedSynchronizer抽象队列同步器原理分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-07 00:28:06" itemprop="dateCreated datePublished" datetime="2022-06-07T00:28:06+08:00">2022-06-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:54:48" itemprop="dateModified" datetime="2022-12-08T09:54:48+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JDK/" itemprop="url" rel="index"><span itemprop="name">JDK</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>继承自AbstractOwnableSynchronizer抽象类, 父类只有一个线程Thread属性, 和这个属性的set和get方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="内部节点"><a href="#内部节点" class="headerlink" title="内部节点"></a>内部节点</h5><p>AbstractQueuedSynchronizer内部是一个双向链表, 而Node就是队列中的每个节点<br>Node表示链表中的节点, 每个节点都有前指针, 后指针, 状态值, 线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">    * unconditionally propagate</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">    *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">    *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">    *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">    *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">    *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">    *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">    *               on failure, block.</span></span><br><span class="line"><span class="comment">    *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">    *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">    *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">    *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">    *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">    *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">    *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">    *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">    *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">    *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">    *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">    *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">    *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">    *               since intervened.</span></span><br><span class="line"><span class="comment">    *   0:          None of the above</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">    * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">    * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">    * values, just for sign.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">    * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">    * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">    * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">    * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">    * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">    * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">    * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">    * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">    * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">    * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">    * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">    * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">    * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">    * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">    * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">    * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">    * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">    * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">    * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">    * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">    * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">    * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">    * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">    * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">    * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">    * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">    * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">    * mode.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">    * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">    * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/01/Java-InheritableThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/01/Java-InheritableThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java-InheritableThreadLocal的使用和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-01 00:01:44" itemprop="dateCreated datePublished" datetime="2022-06-01T00:01:44+08:00">2022-06-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;子线程内：&quot;</span> + inheritableThreadLocal.get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出</span></span><br><span class="line"><span class="comment">* 当前线程：TEST</span></span><br><span class="line"><span class="comment">* 子线程内：TEST</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>InheritableThreadLocal继承自ThreadLocal类, 重写了ThreadLocal的getMap方法和createMap方法, 将这两个方法从操作线程的threadLocals属性改为操作线程对象的另一个属性inheritableThreadLocals</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal操作这个属性</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// InheritableThreadLocal操作这个属性</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：进行set操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocal会调用这个getMap方法操作threadLocals属性</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为InheritableThreadLocal重写了getMap方法, InheritableThreadLocal会调用自己重写的getMap方法操作inheritableThreadLocals属性</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实现父向子传递值的原理在创建Thread线程对象中<br>Thread提供了好多个构造方法, 而每个构造方法最终都会调用init方法进行线程初始化操作, 除了下边特殊标注这个构造方法外, 其他的构造方法调用init初始化都会对inheritableThreadLocals属性进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 特殊的构造方法, 使用此构造方法创建的线程不处理InheritableThreadLocal</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化线程, 只看和InheritableThreadLocal相关的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc, <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">// 如果inheritThreadLocals为true则表示支持InheritableThreadLocal, 那么判断父线程的inheritableThreadLocals是否为null, 当父线程的inheritableThreadLocals不为null时</span></span><br><span class="line">    <span class="comment">// 则把父线程的inheritableThreadLocals赋值给当前线程的inheritableThreadLocals</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个ThreadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>InheritableThreadLocal实现了子线程获取父线程的所保存的值, 也就是实现了父向子进行值传递. 但是却做不到子向父传递值, 传递是单向的. 同时无法在线程池的场景下使用</p>
<h5 id="线程池场景"><a href="#线程池场景" class="headerlink" title="线程池场景"></a>线程池场景</h5><p>父向子传递值是依赖创建子线程对象初始化时进行的赋值, 那么在使用线程池时会出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个只有1个线程的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程2：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;子线程内2：&quot;</span> + inheritableThreadLocal.get()), service);</span><br><span class="line"></span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;TEST2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程2：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;子线程内2：&quot;</span> + inheritableThreadLocal.get()), service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当前线程2：TEST1</span></span><br><span class="line"><span class="comment">* 当前线程2：TEST2</span></span><br><span class="line"><span class="comment">* 子线程内2：TEST1</span></span><br><span class="line"><span class="comment">* 子线程内2：TEST1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如上场景, 两个子线程打印的都是TEST1, 即父线程第二次设置值TEST2, 子线程没有更新<br>原因就是：<br>父向子传值是依赖线程对象创建时初始化的那一刻, 将父线程的值赋值给子线程<br>当线程池中线程被复用而不销毁时, 那么也就没有了创建线程的操作, 自然也就没有父线程赋值给子线程的操作了, 子线程就一直保有自己创建那个时刻获取到的值</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/Java-ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/31/Java-ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java-ThreadLocal使用和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-31 23:06:33" itemprop="dateCreated datePublished" datetime="2022-05-31T23:06:33+08:00">2022-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>可以给当前线程设置一个值, 然后在当前线程的任意位置获取这个值, 任意位置可以是任何方法当中, 只要还在当前线程内就可以获取到<br>一个线程只能保存一个值, 多次赋值会替换掉旧值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">        threadLocal.set(<span class="string">&quot;TEST2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + threadLocal.get());</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;子线程内：&quot;</span> + threadLocal.get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出：</span></span><br><span class="line"><span class="comment">* 当前线程：TEST2</span></span><br><span class="line"><span class="comment">* 子线程内：null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>在Thread对象中有一个属性为ThreadLocal.ThreadLocalMap threadLocals = null; 用来保存ThreadLocal设置的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap是一个类似于Map结构的数据, 内部Entry是一个保存key-value键值对的数据结构(Key是线程对象, Value是保存的属性值), 所有的键值对保存在table数组中<br>所以这里就实现了为每个线程生成一个Entry对象, 用于保存线程和值的映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set方法, 在调用set方法时会获取当前线程对象, 再获取线程内threadLocals属性的值, 依据该值是否为null分别执行添加属性或者初始化这个属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程的threadLocals属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 属性不为null, 则进行set操作, 否则执行创建初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程执行set操作时, threadLocals还未创建值为null, 这里创建ThreadLocalMap并且把当前线程的操作放进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ThreadLocalMap已经被创建, 则会调用set方法向ThreadLocalMap中添加元素, 内部也和HashMap类似, 采用动态数组, 索引是根据Hash值计算, 根据容量进行扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>只能应用于同一个线程内的数据传递, 不能应用于父子线程间数据传递<br>原因是, 每次操作都是获取当前调用的线程所保存的threadLocals值, 那么父线程设置的值, 子线程拿不到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子线程内尝试获取ThreadLocal值</span></span><br><span class="line">CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;子线程内1：&quot;</span> + threadLocal.get()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为是在子线程内, 这里获取的是子线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 因为子线程并没有设置这个值, 所以这里获取到的是null</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个初始化的值(null)</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始化值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个值, 内部是一个抽象方法, 返回的是null(有特殊需求可以重写这个)</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将子线程对象和null作为键值对保存到ThreadLocal中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/SpringBoot-%E6%8E%A5%E5%85%A5Jpa%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/31/SpringBoot-%E6%8E%A5%E5%85%A5Jpa%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">SpringBoot接入Jpa组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-31 22:17:53" itemprop="dateCreated datePublished" datetime="2022-05-31T22:17:53+08:00">2022-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-10 09:54:57" itemprop="dateModified" datetime="2023-03-10T09:54:57+08:00">2023-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">8.0</span><span class="number">.30</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h5><p>给SpringBoot启动类增加@EnableJpaRepositories注解, 以使JPA生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 数据库连接地址</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//192.168.89.128:3306/test?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"># 数据库账号</span><br><span class="line">spring.datasource.username=root</span><br><span class="line"># 数据库密码</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br><span class="line"># 数据库引擎</span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<h5 id="数据库实体"><a href="#数据库实体" class="headerlink" title="数据库实体"></a>数据库实体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;movies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movies</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;times&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查询接口Repository"><a href="#查询接口Repository" class="headerlink" title="查询接口Repository"></a>查询接口Repository</h5><p>自定义查询接口MoviesRepository, 继承JPA查询接口JpaRepository. 并在泛型内执行对应的数据库实体和主键类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MoviesRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Movies</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MoviesRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Movies</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义插入数据SQL, 支持入参为对象:#&#123;#movie.name&#125;语法为获取对象中的属性</span></span><br><span class="line"><span class="comment">    * 插入SQL需要添加事务注解<span class="doctag">@Transactional</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;insert into movies (name, description, author, times) values (:#&#123;#movie.name&#125;,:#&#123;#movie.description&#125;,:#&#123;#movie.author&#125;,:#&#123;#movie.times&#125;)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertMovies</span><span class="params">(<span class="meta">@Param(&quot;movie&quot;)</span> Movies movie)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="业务中使用"><a href="#业务中使用" class="headerlink" title="业务中使用"></a>业务中使用</h5><p>将自定义查询接口MoviesRepository作为依赖注入到服务层即可使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoviesServiceImpl</span> <span class="keyword">implements</span> <span class="title">MoviesService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MoviesRepository moviesRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询所有数据</span></span><br><span class="line">        moviesRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/16/SpringBoot-SpringApplication%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/16/SpringBoot-SpringApplication%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">SpringBoot-SpringApplication初始化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-16 17:03:16" itemprop="dateCreated datePublished" datetime="2022-02-16T17:03:16+08:00">2022-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="note success"><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3></div>
<p>启动一个SpringBoot应用分为两步, 此文章只有第一步的流程</p>
<ol>
<li>创建SpringApplication对象</li>
<li>调用SpringApplication的run方法启动应用</li>
</ol>
<div class="note success"><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></div>
<p>SpringApplication类提供了两个构造方法, 前一个最终也是调用第二个构造方法, 只分析第二个<br>构造方法内部执行分为以下几步:</p>
<ol>
<li>获取和设置启动容器的类型</li>
<li>获取和设置初始化器和监听器</li>
<li>获取和设置启动类对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 1. 获取和设置启动容器的类型</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 2. 获取和设置初始化器和监听器</span></span><br><span class="line">    <span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> ArrayList&lt;&gt;(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 3. 获取和设置启动类对象</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="1-获取容器类型"><a href="#1-获取容器类型" class="headerlink" title="1. 获取容器类型"></a>1. 获取容器类型</h3></div>
<p>Spring定义了要容器启动必要的类路径信息, 此方法根据类路径信息判断是否类是否存在和是否可以加载来确定以哪种容器类型启动应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = &#123; <span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前的web环境. 默认是SpringMVC, 返回结果是WebApplicationType.SERVLET</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前容器是否为servlet</span></span><br><span class="line">    <span class="comment">// &quot;javax.servlet.Servlet&quot;</span></span><br><span class="line">    <span class="comment">// &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span></span><br><span class="line">    <span class="comment">// 当静态变量配置的两个类同时存在且可加载时, 才能按照servlet容器启动. 否则返回NONE</span></span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前容器为servlet</span></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="2-获取初始化器和监听器"><a href="#2-获取初始化器和监听器" class="headerlink" title="2. 获取初始化器和监听器"></a>2. 获取初始化器和监听器</h3></div>
<p>SpringBoot的特性之一就是约定大于配置.在每个引入的依赖包中配置META-INF/spring.factories文件, 文件内配置好要自动装配的组件信息(类全限定名).SpringBoot在启动时会自动将这些组件注入到Spring容器中<br>在创建SpringBoot过程中会调用getSpringFactoriesInstances()方法, 获取Spring预设置好的一些初始化器和监听器<br>此方法会在Spring的以下3个依赖中读取META-INF/spring.factories文件,读取出约定好的要注入的组件信息<br>如org/springframework/boot/spring-boot-autoconfigure/2.6.3/spring-boot-autoconfigure-2.6.3.jar!/META-INF/spring.factories文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br></pre></td></tr></table></figure>


<p>回到构造函数的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取BootstrapRegistryInitializer.class对应的配置</span></span><br><span class="line"><span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> ArrayList&lt;&gt;(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line"><span class="comment">// 获取ApplicationContextInitializer.class对应的配置</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"><span class="comment">// 获取ApplicationListener.class对应的配置</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure>

<p>此方法会根据入参的类, 找到类对应需要创建的对象, 要创建的对象对应的类信息是从spring.factories文件中读取出来的</p>
<ol>
<li>获取当前使用的类加载器, 此处为应用类加载器</li>
<li>使用类加载器获取spring.factories文件信息</li>
<li>利用反射spring.factories文件信息创建对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Class&lt;T&gt; type                 要获取的类型</span></span><br><span class="line"><span class="comment">* Class&lt;?&gt;[] parameterTypes     参数类型, 用于调用构造器创建对象用</span></span><br><span class="line"><span class="comment">* Object... args                一些参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classLoader.getResources(FACTORIES_RESOURCE_LOCATION)此方法可以将应用类加载器可以加载的路径下META-INF/spring.factories文件都读取出来<br>SpringBoot启动时会读取以下配置</p>
<ul>
<li>org/springframework/boot/spring-boot-autoconfigure/2.6.3/spring-boot-autoconfigure-2.6.3.jar!/META-INF/spring.factories</li>
<li>org/springframework/boot/spring-boot/2.6.3/spring-boot-2.6.3.jar!/META-INF/spring.factories</li>
<li>org/springframework/spring-beans/5.3.15/spring-beans-5.3.15.jar!/META-INF/spring.factories</li>
<li>如果自己的应用也定义了META-INF/spring.factories文件, 那么也会被扫描到并处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据传入的类加载器获取数据</span></span><br><span class="line"><span class="comment">* 根据类加载器的类型获取META-INF/spring.factories资源, 读取里面的配置信息</span></span><br><span class="line"><span class="comment">* 将配置信息整理并去重, 保存为Map形式</span></span><br><span class="line"><span class="comment">* ClassLoader classLoader   类加载器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// spring.factories文件的格式分为两级目录, 一级配置做为Key, 二级配置整理为数据做为Value</span></span><br><span class="line">    result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里会将所有应用类加载器可以加载的路径下META-INF/spring.factories文件都读取出来</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">        <span class="comment">// 遍历这些文件</span></span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            <span class="comment">// 解析文件到Properties对象</span></span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="comment">// 将配置文件的子信息整理为数据</span></span><br><span class="line">                String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除重复类全限定名</span></span><br><span class="line">        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">        <span class="comment">// 保存到本地缓存</span></span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此方法对传入的类全限定名信息, 利用反射获取对应的构造器创建对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取类对象</span></span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            <span class="comment">// 获取构造器</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">            <span class="comment">// 利用构造器创建对象</span></span><br><span class="line">            T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回这些对象</span></span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="3-获取启动类对象"><a href="#3-获取启动类对象" class="headerlink" title="3. 获取启动类对象"></a>3. 获取启动类对象</h3></div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            <span class="comment">// 找到main方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                <span class="comment">// 使用反射获取main方法所在类, 也就是启动类, 返回类对象</span></span><br><span class="line">                <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// Swallow and continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/11/Java-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/11/Java-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java-CountDownLatch的使用与原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-11 16:47:49" itemprop="dateCreated datePublished" datetime="2022-02-11T16:47:49+08:00">2022-02-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="使用示例1"><a href="#使用示例1" class="headerlink" title="使用示例1"></a>使用示例1</h5><p>需求：定义一个开关, 用于控制一组10个工作线程何时开始工作, 开关关闭则工作线程都阻塞, 开关打开则工作线程同时开始工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 开关CountDownLatch, 控制工作线程是否开始执行</span></span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 工作CountDownLatch, 判断工作线程是否都执行完成</span></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 提交10个工作线程, 虽然调用了start(), 但是都被内部的开关阻塞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打开开关, startSignal释放, 其他被阻塞线程开始执行</span></span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        <span class="comment">// 阻塞等待10个工作线程执行完成</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 工作线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">            <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞开关, 即被startSignal阻塞</span></span><br><span class="line">                startSignal.await();</span><br><span class="line">                doWork();</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Do something...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用示例2"><a href="#使用示例2" class="headerlink" title="使用示例2"></a>使用示例2</h5><p>需求：阻塞等待10个线程均完成后再继续向下执行逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义10个计数, 表示共10个任务需要执行</span></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 定义一个线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 提交10个线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完成</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">        WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doWork(<span class="keyword">this</span>.i);</span><br><span class="line">            <span class="comment">// 当前线程执行完成, CountDownLatch-1操作</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Do something...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="作用和实现原理"><a href="#作用和实现原理" class="headerlink" title="作用和实现原理"></a>作用和实现原理</h5><p>底层基于AbstractQueuedSynchronizer抽象队列同步器实现, AbstractQueuedSynchronizer抽象队列同步器主要实现的是基于状态值绝对当前线程是否等待, 内部包含一个线程队列, 等待的线程都放在该队列中<br>CountDownLatch利用了AbstractQueuedSynchronizer抽象队列同步器的机制, 预设了一定的计数作为状态值, CountDownLatch每次-1操作时, 也就是对状态值得操作<br>最终状态值归0时, 队列中的线程被唤醒继续执行. 具体原理看AbstractQueuedSynchronizer的介绍</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>CountDownLatch有一个内部类Sync, 这个内部类继承了AbstractQueuedSynchronizer抽象队列同步器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sync类, 继承自AbstractQueuedSynchronizer抽象队列同步器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置CountDownLatch初始计数, 也就是AbstractQueuedSynchronizer的状态值</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取CountDownLatch当前计数, 也就是AbstractQueuedSynchronizer的状态值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取资源, 如果没有可以资源返回1, 否则返回-1</span></span><br><span class="line"><span class="comment">    * 重写了父类的方法, 此方法会从父类调过来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试释放资源</span></span><br><span class="line"><span class="comment">    * 重写了父类的方法, 此方法会从父类调过来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自旋操作, 直到有操作返回</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 当前没有资源, 返回false</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 存在资源, 资源数-1</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 以CAS形式赋值, 即自旋锁形式</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// 赋值成功, 当前释放的是最后一个资源计数, 则返回true, 如果依然有其他资源未释放则返回false</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个使用给定计数(线程数)初始化的CountDownLatch, 创建一个Sync对象, CountDownLatch的计数操作都是对Sync对象的操作</span></span><br><span class="line"><span class="comment">* 线程可以通过await之前必须调用countDown的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h5><p>阻塞方法有两个, 其中一个带超时功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当前线程等待直到锁存器倒计时到零</span></span><br><span class="line"><span class="comment">* 如果当前计数为零，则此方法立即返回</span></span><br><span class="line"><span class="comment">* 如果当前计数大于零, 则当前线程出于线程调度目的而被禁用并处于休眠状态, 直到发生以下两种情况之一:</span></span><br><span class="line"><span class="comment">* 由于调用了countDown方法，计数达到零</span></span><br><span class="line"><span class="comment">* 其他一些线程中断当前线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当前线程等待直到锁存器倒计时到零</span></span><br><span class="line"><span class="comment">* 如果当前计数为零，则此方法立即返回</span></span><br><span class="line"><span class="comment">* 如果当前计数大于零, 则当前线程出于线程调度目的而被禁用并处于休眠状态, 直到发生以下三种情况之一:</span></span><br><span class="line"><span class="comment">* 由于调用了countDown方法，计数达到零</span></span><br><span class="line"><span class="comment">* 其他一些线程中断当前线程</span></span><br><span class="line"><span class="comment">* 指定的等待时间已过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="减少资源"><a href="#减少资源" class="headerlink" title="减少资源"></a>减少资源</h5><p>释放资源直接调用Sync对象的releaseShared方法, Sync没有实现这个方法, 则直接调用父类AbstractQueuedSynchronizer的releaseShared方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 减少锁存器的计数，如果计数达到零，则释放所有等待线程。</span></span><br><span class="line"><span class="comment">* 如果当前计数大于零，则递减。</span></span><br><span class="line"><span class="comment">* 如果递减后新计数为零，则重新启用所有等待线程以进行线程调度。</span></span><br><span class="line"><span class="comment">* 如果当前计数为零，则不会发生任何事情。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取计数"><a href="#获取计数" class="headerlink" title="获取计数"></a>获取计数</h5><p>获取计数直接调用Sync对象的getCount方法获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回当前计数。</span></span><br><span class="line"><span class="comment">* 此方法通常用于调试和测试目的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/31/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/31/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java-反射机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-31 13:27:58" itemprop="dateCreated datePublished" datetime="2022-01-31T13:27:58+08:00">2022-01-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="note success"><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></div>
<p>当需要动态生成class对象时, 可以使用反射机制<br>使用反射可以使用配置文件, 配置文件内保存类全路径和方法名, 反射机制通过这些字符串信息找到对应的类并创建对象, 还可以根据方法名调用方法</p>
<div class="note success"><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3></div>
<ol>
<li>反射是框架开发的基础</li>
<li>反射机制允许程序在执行期间借助ReflectionAPI获取任何类的内部信息, 并能操作对象的属性和方法</li>
<li>常用的反射操作类都在java.lang.reflect包中</li>
<li>在类对象中方法和属性都是对象, 保存在类对象中, 可以使用Method和Field类操作方法和属性对象</li>
</ol>
<div class="note success"><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3></div>
<ol>
<li>当需要创建一个对象时, JVM会基于.class字节码文件生成类对应的class文件 </li>
<li>每个类有且只有一个对应的Class对象, 即连续两次创建对象时只有第一次会触发类加载</li>
<li>生成的类对象保存在堆内存中</li>
<li>对象内保存了类的一些结构信息, 包括有哪些属性, 方法, 构造器等信息. 这些信息以对象数组的形式保存在类对象中</li>
<li>类加载完成后, 新创建的对象会拥有一个指针指向这个类对象</li>
</ol>
<div class="note success"><h3 id="类加载源码"><a href="#类加载源码" class="headerlink" title="类加载源码"></a>类加载源码</h3></div>
<ol>
<li>使用synchronized锁保证多线程并发情况的类加载, 确保类只加载一次</li>
<li>如果类是第一次加载, 则基于双亲委派机制进行类加载</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 增加对象锁, 保证多线程创建对象时只有1个线程可以进行类加载操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 判断类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3></div>
<p>枚举是一种类, 注解是一种接口<br>每个数组也是一个类, 该类反映为一个Class对象, 该对象由具有相同元素类型和维数的所有数组共享<br>原始 Java 类型（ boolean 、 byte 、 char 、 short 、 int 、 long 、 float和double ）和关键字void也表示为Class对象<br>Class没有公共构造函数, Class对象是由 Java 虚拟机在加载类时自动构造的,并通过调用类加载器中的defineClass方法来构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class类的实例表示正在运行的 Java 应用程序中的类和接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">GenericDeclaration</span>, <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Field提供有关类或接口的单个字段的信息和对它们的动态访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method提供有关类或接口上的单个方法的信息和对它的访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor提供有关类的单个构造函数的信息和访问权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3></div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类全限定名获取类对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.User&quot;</span>);</span><br><span class="line"><span class="comment">// 获取方法列表</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="comment">// 通过方法名获取方法对象</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="comment">// 获取有参构造器, 传入参数类型</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 获取构造器列表</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="comment">// 获取指定属性</span></span><br><span class="line">Field name = clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="comment">// 通过类对象获取实例对象</span></span><br><span class="line">Object instance = clazz.newInstance();</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/31/Redis-AOF%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/31/Redis-AOF%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">Redis-AOF文件加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-31 13:24:13" itemprop="dateCreated datePublished" datetime="2022-01-31T13:24:13+08:00">2022-01-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="note success"><h3 id="加载AOF-C系统函数"><a href="#加载AOF-C系统函数" class="headerlink" title="加载AOF-C系统函数"></a>加载AOF-C系统函数</h3></div>

<p>使用到的一些C系统函数</p>
<ol>
<li>fgets(): char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</li>
<li>fread(): size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</li>
<li>atoi(): int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）</li>
<li>strtol(): long int strtol(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0</li>
<li>feof(): int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。</li>
<li>fseek(): int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数. SEEK_SET文件开头</li>
<li>truncate(): int truncate(const char * path, off_t length); truncate()会将参数path 指定的文件大小改为参数length 指定的大小. 如果原来的文件大小比参数length 大, 则超过的部分会被删去.</li>
</ol>
<div class="note success"><h3 id="加载AOF-文件载入"><a href="#加载AOF-文件载入" class="headerlink" title="加载AOF-文件载入"></a>加载AOF-文件载入</h3></div>

<p>加载流程:</p>
<ol>
<li>读取AOF文件, 确认正确打开了AOF文件</li>
<li>创建一个不带网络连接的假客户端, 用这个客户端模拟执行AOF文件中的命令</li>
<li>如果有RDB前导码, 则处理</li>
<li>循环读取AOF文件中的内存, 填充到假客户端中</li>
<li>使用假客户端执行此命令</li>
<li>循环4,5步直至AOF文件结束</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个客户端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    <span class="comment">// 以读取模式打开AOF文件</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录正确执行的命令字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录批量命令的字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> valid_before_multi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// AOF文件打开失败了</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOF文件是空的, 空的AOF文件是合法的. 因为服务器在启动时会创建一个空的AOF文件, 如果没有收到写入操作, 那么就一直不变</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时禁用AOF, 以防止 EXEC 向我们将要读取的同一文件提供 MULTI</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line">    <span class="comment">// 创建一个不带网络连接的假客户端, 用于执行AOF内的写命令</span></span><br><span class="line">    fakeClient = createAOFClient();</span><br><span class="line">    <span class="comment">// 开始加载AOF文件</span></span><br><span class="line">    startLoadingFile(fp, filename, RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查AOF文件的前5个字符是否是&quot;REDIS&quot;, 如果是则表示需要加载RDB文件</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不需要加载RDB文件, 将文件流指针指回文件开头</span></span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加载RDB文件</span></span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">        <span class="comment">// 将文件流指针指回文件开头</span></span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">        <span class="comment">// 加载RDB文件, 加载完成后再继续处理AOF</span></span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始在AOF文件中依次处理写入命令</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc, j;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里为客户端请求提供服务, 不能一直执行AOF文件加载</span></span><br><span class="line">        <span class="comment">// 每执行1000条AOF数据, 则执行一次IO事件处理</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">            processModuleLoadingProgressEvent(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件流中读取一行数据, 保存到buf中, 如果返回NULL, 则要判断文件是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检测文件流上的文件结束符, 如果结束则跳出, 如果未结束则跳转到错误</span></span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查命令的协议格式是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        <span class="comment">// 取出buf第二个元素, 并转成整数, 第二个元素保存的是参数数量</span></span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 参数数量少于1个, 不合法</span></span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给参数分配内存</span></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        <span class="comment">// 将参数和参数数量赋值给客户端</span></span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 遍历参数, 处理每个参数. 此处循环3次, 每次处理两行(一行长度,一行数据)</span></span><br><span class="line"><span class="comment">        * *3</span></span><br><span class="line"><span class="comment">        * $3</span></span><br><span class="line"><span class="comment">        * SET</span></span><br><span class="line"><span class="comment">        * $22</span></span><br><span class="line"><span class="comment">        * city:broadcast:v2:1130</span></span><br><span class="line"><span class="comment">        * $13</span></span><br><span class="line"><span class="comment">        * 这是内容~</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">// 从文件中读取一行参数, 如果读取失败, 则记录当前的行数</span></span><br><span class="line">            <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j;</span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果参数的第一位不是$, 不合法</span></span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">            <span class="comment">// buf+1取出的是字符串类型的参数长度, 将这个参数长度转成长整数</span></span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 根据长度创建一个SDS对象</span></span><br><span class="line">            argsds = sdsnewlen(SDS_NOINIT,len);</span><br><span class="line">            <span class="comment">// 根据长度, 从文件流中读取参数.保存到SDS对象中</span></span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j;</span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 创建对象, 并保存到argv元素中</span></span><br><span class="line"><span class="comment">            * argv[0] -&gt; 命令类型-SET</span></span><br><span class="line"><span class="comment">            * argv[1] -&gt; KEY</span></span><br><span class="line"><span class="comment">            * argv[2] -&gt; VALUE</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">            <span class="comment">// 读取后面的两个字符 &quot;\r\n&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>;</span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// argv[0]保存的是此命令的命令类型, 找到对应的命令方法</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="comment">// 如果命令没找到</span></span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING, <span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>, (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == server.multiCommand) valid_before_multi = valid_up_to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这个假的客户端执行命令</span></span><br><span class="line">        fakeClient-&gt;cmd = cmd;</span><br><span class="line">        <span class="comment">// 判断当前指令是否为事务</span></span><br><span class="line">        <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp; fakeClient-&gt;cmd-&gt;proc != execCommand) &#123;</span><br><span class="line">            queueMultiCommand(fakeClient);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd-&gt;proc(fakeClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假的客户端不需要回复</span></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假客户端永远不应该被阻止</span></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放客户端参数</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="comment">// 将客户端命令重置为NULL, 用于处理下一次循环</span></span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 如果设置了不在意外的AOF结束符EOF上停下来, 记录已读取的字节数到valid_up_to参数中, 表示到此字节数AOF文件读取是正常的</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">        <span class="comment">// 如果设置了加载aof 或 rdb 时键之间的延迟（以微秒为单位）</span></span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有错误的情况下到达EOF结束符时, 客户端处于 MULTI/EXEC (即事务)的中间. 要删除未处理的尾部并继续程序的执行</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;</span>);</span><br><span class="line">        valid_up_to = valid_before_multi;</span><br><span class="line">        <span class="keyword">goto</span> uxeof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载完成, 返回OK给调用方</span></span><br><span class="line">loaded_ok:</span><br><span class="line">    <span class="comment">// 关闭AOF文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">// 释放客户端资源</span></span><br><span class="line">    freeFakeClient(fakeClient);</span><br><span class="line">    <span class="comment">// 恢复AOF状态</span></span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    stopLoading(<span class="number">1</span>);</span><br><span class="line">    aofUpdateCurrentSize();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 读取错误处理</span></span><br><span class="line">readerr:</span><br><span class="line">    <span class="comment">// 文件未到达结束位置</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="comment">// 释放客户端资源</span></span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient);</span><br><span class="line">        <span class="comment">// 关闭AOF文件</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意外的AOF文件结尾</span></span><br><span class="line">uxeof:</span><br><span class="line">    <span class="comment">// 如果设置了不在意外的AOF结束符EOF上停下来</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) valid_up_to);</span><br><span class="line">        <span class="comment">// 当开启aof_load_truncated时, valid_up_to会记录已经正确处理的命令的字节数. 如果此值为-1, 那么表示记录字节数出现错误. 则记录错误同时结束程序</span></span><br><span class="line">        <span class="comment">// valid_up_to不等于-1时, 会尝试使用这个值对AOF文件进行截取, 如果截取失败了, 也记录错误并结束程序</span></span><br><span class="line">        <span class="comment">// 如果截取成功了, 则走else逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 截取AOF文件到正确记录的偏移量valid_up_to</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 确保AOF文件描述符在truncate调用后指向文件末尾, 如果指向操作失败, 则记录错误并结束程序</span></span><br><span class="line">            <span class="comment">// 成功则走正常结束逻辑, 返回给调用方OK</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>, strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容格式错误</span></span><br><span class="line">fmterr:</span><br><span class="line">    <span class="comment">// 释放客户端资源</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient);</span><br><span class="line">    <span class="comment">// 关闭AOF文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/31/Redis-AOF%E9%87%8D%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/31/Redis-AOF%E9%87%8D%E5%86%99/" class="post-title-link" itemprop="url">Redis-AOF重写</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-31 13:23:59" itemprop="dateCreated datePublished" datetime="2022-01-31T13:23:59+08:00">2022-01-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-12-08 09:48:40" itemprop="dateModified" datetime="2022-12-08T09:48:40+08:00">2022-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="note success"><h3 id="重写AOF-触发入口"><a href="#重写AOF-触发入口" class="headerlink" title="重写AOF-触发入口"></a>重写AOF-触发入口</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 手动输入指令BGREWRITEAOF触发AOF重写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgrewriteaofCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AOF后台重写已经在进行中</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;Background append only file rewriting already in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 当前有AOF重写子进程或RDB保存子进程或模块子进程在执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">1</span>;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting scheduled&quot;</span>);</span><br><span class="line">    <span class="comment">// 开始AOF重写</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting started&quot;</span>);</span><br><span class="line">    <span class="comment">// 不能进行AOF重写,服务出现错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;Can&#x27;t execute an AOF background rewriting. &quot;</span><span class="string">&quot;Please check the server logs for more information.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* severCron事件事件检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    其他逻辑......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AOF开关为开启状态</span></span><br><span class="line">    <span class="comment">// 没有正在进行的子进程</span></span><br><span class="line">    <span class="comment">// aof_rewrite_perc为开启状态, 即设置了增长率阈值</span></span><br><span class="line">    <span class="comment">// 一半aof_rewrite_min_size设置为服务器内存的1/4, 则当AOF文件大小超过这个值时, 触发AOF重写</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp; !hasActiveChildProcess() &amp;&amp; server.aof_rewrite_perc &amp;&amp; server.aof_current_size &gt; server.aof_rewrite_min_size) &#123;</span><br><span class="line">        <span class="comment">// aof_rewrite_base_size为上次重写AOF后, AOF文件的大小. 用于计算增长率</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> base = server.aof_rewrite_base_size ? server.aof_rewrite_base_size : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算增长率</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> growth = (server.aof_current_size*<span class="number">100</span>/base) - <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 当增长率大于阈值aof_rewrite_perc, 进行AOF重写, aof_rewrite_perc一半设置为100</span></span><br><span class="line">        <span class="keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;</span>,growth);</span><br><span class="line">            rewriteAppendOnlyFileBackground();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    其他逻辑......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-进程与通道"><a href="#重写AOF-进程与通道" class="headerlink" title="重写AOF-进程与通道"></a>重写AOF-进程与通道</h3></div>
<ol>
<li>创建子进程</li>
<li>开启通道</li>
<li>生成AOF临时文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="comment">// 判断当前是否有其他子进程在执行</span></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 为AOF重写创建通道</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    <span class="comment">// fork(), 开启子进程, 并保存子进程的进程号PID</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 定义临时存储</span></span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 向临时文件写入AOF数据</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_AOF, <span class="string">&quot;AOF rewrite&quot;</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        <span class="comment">// 标记正在进行AOF重写, 避免下一次文件事件循环重复调用</span></span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录AOF重写开始事件</span></span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 记录子进程PID</span></span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        <span class="comment">// aof_selected_db设置为-1, 标志下一次AOF日志强制加上select, 确保命令可以执行到正确的数据库</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-创建管道"><a href="#重写AOF-创建管道" class="headerlink" title="重写AOF-创建管道"></a>重写AOF-创建管道</h3></div>
<ol>
<li>重写期间创建用于父子进程IPC的管道</li>
<li>一共开启3条通道,6个fd文件描述符</li>
<li>管道1: 负责父向子发送差异数据, 父向通道写入数据, 子从通道读取数据</li>
<li>管道2: 负责子向父发送确认信号, 用于要求父停止向通道写入数据, 子向通道写入符号”!”, 父从通道读取符号”!”. 并停止向通道写入差异数据</li>
<li>管道3: 负责父向子发送回复信号, 父接收到停止写入信号后, 处理本地差异数据, 然后向通道写入回复消息, 子从通道读取到回复消息, 处理AOF重写</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aofCreatePipes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 父进程向子进程发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="comment">// 子进程向父进程发送确认</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds+<span class="number">2</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="comment">// 父进程向子进程回复确认</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(fds+<span class="number">4</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,fds[<span class="number">0</span>]) != ANET_OK) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,fds[<span class="number">1</span>]) != ANET_OK) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="comment">// 创建文件事件-fds[2]的可读事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, fds[<span class="number">2</span>], AE_READABLE, aofChildPipeReadable, <span class="literal">NULL</span>) == AE_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="comment">// 向子进程写入数据的文件描述符</span></span><br><span class="line">    server.aof_pipe_write_data_to_child = fds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从父进程读取数据的文件描述符</span></span><br><span class="line">    server.aof_pipe_read_data_from_parent = fds[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 向父进程写入确认的文件描述符</span></span><br><span class="line">    server.aof_pipe_write_ack_to_parent = fds[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 从子进程读取确认的文件描述符</span></span><br><span class="line">    server.aof_pipe_read_ack_from_child = fds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 向子进程写入回复的文件描述符</span></span><br><span class="line">    server.aof_pipe_write_ack_to_child = fds[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 从父进程读取回复的文件描述符</span></span><br><span class="line">    server.aof_pipe_read_ack_from_parent = fds[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 停止管道传输的标志</span></span><br><span class="line">    server.aof_stop_sending_diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Error opening /setting AOF rewrite IPC pipes: %s&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="keyword">if</span>(fds[j] != <span class="number">-1</span>) close(fds[j]);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-关闭管道"><a href="#重写AOF-关闭管道" class="headerlink" title="重写AOF-关闭管道"></a>重写AOF-关闭管道</h3></div>
<p>删除文件事件, 关闭管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofClosePipes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);</span><br><span class="line">    aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);</span><br><span class="line">    close(server.aof_pipe_write_data_to_child);</span><br><span class="line">    close(server.aof_pipe_read_data_from_parent);</span><br><span class="line">    close(server.aof_pipe_write_ack_to_parent);</span><br><span class="line">    close(server.aof_pipe_read_ack_from_child);</span><br><span class="line">    close(server.aof_pipe_write_ack_to_child);</span><br><span class="line">    close(server.aof_pipe_read_ack_from_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-管道事件"><a href="#重写AOF-管道事件" class="headerlink" title="重写AOF-管道事件"></a>重写AOF-管道事件</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofChildPipeReadable</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> byte;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取通道数据, 如果接收到了符号&quot;!&quot;. 表示收到确认信息, 停止向管道写入AOF差异数据</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,&amp;byte,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; byte == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;AOF rewrite child asks to stop sending diffs.&quot;</span>);</span><br><span class="line">        <span class="comment">// 停止管道传输, 停止向管道写入AOF差异数据</span></span><br><span class="line">        server.aof_stop_sending_diff = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向管道写入符号&quot;!&quot;, 表示父进程接收到了子进程的确认信息, 回复&quot;!&quot;表示自己已经收到</span></span><br><span class="line">        <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_child,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果向子进程回复ACK失败, 则程序继续, 子进程有超时等待处理</span></span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t send ACK to AOF child: %s&quot;</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个事件只处理一次, 移除事件</span></span><br><span class="line">    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-Fork-子进程"><a href="#重写AOF-Fork-子进程" class="headerlink" title="重写AOF-Fork()子进程"></a>重写AOF-Fork()子进程</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redisFork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childpid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime();</span><br><span class="line">    <span class="comment">// 返回进程PID不为0, 则表示当前是父进程.</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line">        setupChildSignalHandlers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 停止Hash结构的数据resize操作, 避免内存拷贝</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-命令写入与差异处理"><a href="#重写AOF-命令写入与差异处理" class="headerlink" title="重写AOF-命令写入与差异处理"></a>重写AOF-命令写入与差异处理</h3></div>
<ol>
<li>打开AOF临时文件</li>
<li>RIO流模式进行数据写入</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we have to use a different temp name here compared to the</span></span><br><span class="line"><span class="comment">     * one used by rewriteAppendOnlyFileBackground() function. */</span></span><br><span class="line">    <span class="comment">// 生成临时AOF文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    <span class="comment">// 以写入模式打开临时AOF文件</span></span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启AOF重写缓冲区, 用于接收重写过程中的写命令</span></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    <span class="comment">// 定义RIO流式IO</span></span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了要立即磁盘同步, 则给RIO流设置自动磁盘同步的字节数, 即每当写入这些字节数进行自动磁盘同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;aof,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发持久化开始事件</span></span><br><span class="line">    startSaving(RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">            errno = error;</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行重写AOF</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程还在向子进程写入差异数据, 此时先对AOF重写的数据进行刷盘.后续处理差异数据时就只需要对少量的差异数据进行刷盘了</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> start = mstime();</span><br><span class="line">    <span class="comment">// 父进程接收客户端数据的速度可能比他发送给子进程的速度快</span></span><br><span class="line">    <span class="comment">// 所以这里的循环是尝试在一个循环中读取尽可能多的数据, 一起处理</span></span><br><span class="line">    <span class="comment">// 每个事件等待时长是1ms, 循环20次即结束进行数据处理.</span></span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nodata++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodata = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行从父进程读取差异数据, 将读取到的差异数据保存到aof_child_diff中</span></span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向通道写入符号&quot;!&quot;, 要求父进程停止向管道写入差异数据, 即现在要处理累积的差异数据</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 以超时时间10秒从通道读取父进程发送的回复信号&quot;!&quot;, 得到回复才能确定父进程已经停止写入, 证明现在可以处理差异数据. </span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> || byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次执行从父进程读取差异数据, 将读取到的差异数据保存到aof_child_diff中, 此处为最终的差异</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>, (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">// 调用rioWrite()将接收到的差异写入新的AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保数据不会保留在操作系统的输出缓冲区中, 强制刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重命名AOF临时文件方式, 替换原来的AOF文件.</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    <span class="comment">// 触发持久化结束事件</span></span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-命令生成与写入"><a href="#重写AOF-命令生成与写入" class="headerlink" title="重写AOF-命令生成与写入"></a>重写AOF-命令生成与写入</h3></div>
<ol>
<li>遍历所有数据库</li>
<li>先生成选择数据库命令 select 0</li>
<li>获取数据库所有key的字典, 转成迭代器</li>
<li>迭代处理每一个key<ol>
<li>获取key对应的value和有效期</li>
<li>根据key的类型调用对应的方法生成写命令, 并写入文件</li>
<li>如果带有有效期的key, 则再写入一条设置有效期的写命令</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileRio</span><span class="params">(rio *aof)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 遍历所有数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 组装选择数据库命令</span></span><br><span class="line">        <span class="keyword">char</span> selectcmd[] = <span class="string">&quot;*2\r\n$6\r\nSELECT\r\n&quot;</span>;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        <span class="comment">// 获取数据库字典表</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="comment">// 字典为空, 表示当前数据库没有key</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 转成迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入选择数据库命令, 拼接\r\n换行符</span></span><br><span class="line">        <span class="keyword">if</span> (rioWrite(aof,selectcmd,<span class="keyword">sizeof</span>(selectcmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkLongLong(aof,j) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 迭代数据库中的每个key</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr;</span><br><span class="line">            robj key, *o;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</span><br><span class="line">            <span class="comment">// 获取key</span></span><br><span class="line">            keystr = dictGetKey(de);</span><br><span class="line">            <span class="comment">// 获取value</span></span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            <span class="comment">// 获取key的有效期</span></span><br><span class="line">            expiretime = getExpire(db,&amp;key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据value的类型处理数据, 调用对应方法执行命令生成和写入文件逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type == OBJ_STRING) &#123;</span><br><span class="line">                <span class="comment">// 字符串类型的处理</span></span><br><span class="line">                <span class="keyword">char</span> cmd[]=<span class="string">&quot;*3\r\n$3\r\nSET\r\n&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (rioWrite(aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteListObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteSetObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteHashObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_STREAM) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteStreamObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_MODULE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rewriteModuleObject(aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unknown object type&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当key设置了有效时间时, 保存key的有效时间</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> cmd[]=<span class="string">&quot;*3\r\n$9\r\nPEXPIREAT\r\n&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (rioWrite(aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理AOF重写缓冲区数据</span></span><br><span class="line">            <span class="keyword">if</span> (aof-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES) &#123;</span><br><span class="line">                processed = aof-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-List列表处理"><a href="#重写AOF-List列表处理" class="headerlink" title="重写AOF-List列表处理"></a>重写AOF-List列表处理</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteListObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>, items = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklist *<span class="built_in">list</span> = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 转成迭代器</span></span><br><span class="line">        quicklistIter *li = quicklistGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">        quicklistEntry entry;</span><br><span class="line">        <span class="comment">// 迭代所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (quicklistNext(li,&amp;entry)) &#123;</span><br><span class="line">            <span class="comment">// 处理第一个元素时, 写入命令协议</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">                <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">                <span class="comment">// 写入参数数量</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入命令类型-RPUSH</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;RPUSH&quot;</span>,<span class="number">5</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入key</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (entry.value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,(<span class="keyword">char</span>*)entry.value,entry.sz) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(r,entry.longval) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">            <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">            items--;</span><br><span class="line">        &#125;</span><br><span class="line">        quicklistReleaseIterator(li);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-Set集合处理"><a href="#重写AOF-Set集合处理" class="headerlink" title="重写AOF-Set集合处理"></a>重写AOF-Set集合处理</h3></div>
<ol>
<li>针对集合的类型分别处理: 整数集合或哈希表</li>
<li>每生成的一条写命令最多包含64个元素, 超出64个元素要再生成一条新的写命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteSetObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取集合的元素个数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>, items = setTypeSize(o);</span><br><span class="line">    <span class="comment">// 集合是整数集合</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> llval;</span><br><span class="line">        <span class="comment">// 循环拉取集合元素, 并处理</span></span><br><span class="line">        <span class="keyword">while</span>(intsetGet(o-&gt;ptr,ii++,&amp;llval)) &#123;</span><br><span class="line">            <span class="comment">// 处理第一个元素时, 写入命令协议</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">                <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">                <span class="comment">// 写入参数数量</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入命令类型-SADD</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;SADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入key</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入value</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkLongLong(r,llval) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">            <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">            items--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 集合是哈希表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 获取集合的Hash表数据并转换成迭代器</span></span><br><span class="line">        dictIterator *di = dictGetIterator(o-&gt;ptr);</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代所有集合元素, 并处理</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取元素对象</span></span><br><span class="line">            sds ele = dictGetKey(de);</span><br><span class="line">            <span class="comment">// 处理第一个元素时, 写入命令协议</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">                <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">                <span class="comment">// 写入参数数量</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入命令类型-SADD</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;SADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入key</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入value</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,ele,sdslen(ele)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">            <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">            items--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放迭代器</span></span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-SortedSet有序集合处理"><a href="#重写AOF-SortedSet有序集合处理" class="headerlink" title="重写AOF-SortedSet有序集合处理"></a>重写AOF-SortedSet有序集合处理</h3></div>
<ol>
<li>针对集合的类型分别处理: 压缩列表或跳表</li>
<li>每生成的一条写命令最多包含64个元素, 超出64个元素要再生成一条新的写命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteSortedSetObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取集合元素个数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>, items = zsetLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有序集合是压缩列表</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = o-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">        eptr = ziplistIndex(zl,<span class="number">0</span>);</span><br><span class="line">        serverAssert(eptr != <span class="literal">NULL</span>);</span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line">        serverAssert(sptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (eptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverAssert(ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vll));</span><br><span class="line">            <span class="comment">// 获取分数</span></span><br><span class="line">            score = zzlGetScore(sptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">                <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">                <span class="comment">// 写入参数数量</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items*<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入命令类型-ZADD</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;ZADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入key</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入分数</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkDouble(r,score) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (vstr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,(<span class="keyword">char</span>*)vstr,vlen) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(r,vll) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">            <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">            items--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 有序集合是跳表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        dictIterator *di = dictGetIterator(zs-&gt;dict);</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds ele = dictGetKey(de);</span><br><span class="line">            <span class="keyword">double</span> *score = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">                <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">                <span class="comment">// 写入参数数量</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items*<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入命令类型-ZADD</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;ZADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 写入key</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入命令协议第四部分(分数)</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkDouble(r,*score) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入命令协议第五部分(元素)</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,ele,sdslen(ele)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">            <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">            items--;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted zset encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-Hash哈希表处理"><a href="#重写AOF-Hash哈希表处理" class="headerlink" title="重写AOF-Hash哈希表处理"></a>重写AOF-Hash哈希表处理</h3></div>
<ol>
<li>将Hash表转成迭代器, 迭代处理每个元素</li>
<li>每生成的一条写命令最多包含64个元素, 超出64个元素要再生成一条新的写命令(所以Hash表的一条写命令最多32个键值对)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteHashObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    hashTypeIterator *hi;</span><br><span class="line">    <span class="comment">// 获取Hash表元素个数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>, items = hashTypeLength(o);</span><br><span class="line">    <span class="comment">// 转成迭代器</span></span><br><span class="line">    hi = hashTypeInitIterator(o);</span><br><span class="line">    <span class="comment">// 迭代所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每一行写命令最多处理64个元素</span></span><br><span class="line">            <span class="keyword">int</span> cmd_items = (items &gt; AOF_REWRITE_ITEMS_PER_CMD) ? AOF_REWRITE_ITEMS_PER_CMD : items;</span><br><span class="line">            <span class="comment">// 写入参数数量, 计算方式为 2 + 2 * 元素个数</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>+cmd_items*<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入命令类型-HMSET</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;HMSET&quot;</span>,<span class="number">5</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入key</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入hash-key</span></span><br><span class="line">        <span class="keyword">if</span> (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 写入hash-value</span></span><br><span class="line">        <span class="keyword">if</span> (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每一行写命令最多处理64个元素, 重置计数</span></span><br><span class="line">        <span class="keyword">if</span> (++count == AOF_REWRITE_ITEMS_PER_CMD) count = <span class="number">0</span>;</span><br><span class="line">        items--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashTypeReleaseIterator(hi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分类型处理Hash的key和value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rioWriteHashIteratorCursor</span><span class="params">(rio *r, hashTypeIterator *hi, <span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Hash表采用压缩列表存储</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen = UINT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll = LLONG_MAX;</span><br><span class="line">        <span class="comment">// 根据迭代器获取指定指针位置数据</span></span><br><span class="line">        hashTypeCurrentFromZiplist(hi, what, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">        <span class="keyword">if</span> (vstr)</span><br><span class="line">            <span class="keyword">return</span> rioWriteBulkString(r, (<span class="keyword">char</span>*)vstr, vlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rioWriteBulkLongLong(r, vll);</span><br><span class="line">    <span class="comment">// 哈希表使用哈希存储</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        sds value = hashTypeCurrentFromHashTable(hi, what);</span><br><span class="line">        <span class="keyword">return</span> rioWriteBulkString(r, value, sdslen(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-Stream流处理"><a href="#重写AOF-Stream流处理" class="headerlink" title="重写AOF-Stream流处理"></a>重写AOF-Stream流处理</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteStreamObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    stream *s = o-&gt;ptr;</span><br><span class="line">    streamIterator si;</span><br><span class="line">    streamIteratorStart(&amp;si,s,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    streamID id;</span><br><span class="line">    <span class="keyword">int64_t</span> numfields;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;length) &#123;</span><br><span class="line">        <span class="comment">// 使用XADD重建流数据</span></span><br><span class="line">        <span class="keyword">while</span>(streamIteratorGetID(&amp;si,&amp;id,&amp;numfields)) &#123;</span><br><span class="line">            <span class="comment">// 写入参数数量</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">3</span>+numfields*<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入命令类型-XADD</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;XADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入key</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 写入流ID</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkStreamID(r,&amp;id) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环写入字段和值</span></span><br><span class="line">            <span class="keyword">while</span>(numfields--) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *field, *value;</span><br><span class="line">                <span class="keyword">int64_t</span> field_len, value_len;</span><br><span class="line">                streamIteratorGetField(&amp;si,&amp;field,&amp;value,&amp;field_len,&amp;value_len);</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,(<span class="keyword">char</span>*)field,field_len) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkString(r,(<span class="keyword">char</span>*)value,value_len) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果要处理的key是空的, 则生成一个空流 SADD MAXLEN 0</span></span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">7</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;XADD&quot;</span>,<span class="number">4</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;MAXLEN&quot;</span>,<span class="number">6</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;0&quot;</span>,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkStreamID(r,&amp;s-&gt;last_id) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;x&quot;</span>,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;y&quot;</span>,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 XADD 之后附加 XSETID，确保 lastid 正确，以防 XDEL lastid。</span></span><br><span class="line">    <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">3</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;XSETID&quot;</span>,<span class="number">6</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rioWriteBulkStreamID(r,&amp;s-&gt;last_id) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建所有流消费者组</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;cgroups) &#123;</span><br><span class="line">        raxIterator ri;</span><br><span class="line">        raxStart(&amp;ri,s-&gt;cgroups);</span><br><span class="line">        raxSeek(&amp;ri,<span class="string">&quot;^&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">            streamCG *group = ri.data;</span><br><span class="line">            <span class="comment">// 发出 XGROUP CREATE 以创建组</span></span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkCount(r,<span class="string">&#x27;*&#x27;</span>,<span class="number">5</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;XGROUP&quot;</span>,<span class="number">6</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,<span class="string">&quot;CREATE&quot;</span>,<span class="number">6</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkObject(r,key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkString(r,(<span class="keyword">char</span>*)ri.key,ri.key_len) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioWriteBulkStreamID(r,&amp;group-&gt;last_id) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为每个碰巧有待处理条目的消费者生成 XCLAIM, 空消费者丢弃</span></span><br><span class="line">            raxIterator ri_cons;</span><br><span class="line">            raxStart(&amp;ri_cons,group-&gt;consumers);</span><br><span class="line">            raxSeek(&amp;ri_cons,<span class="string">&quot;^&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(raxNext(&amp;ri_cons)) &#123;</span><br><span class="line">                streamConsumer *consumer = ri_cons.data;</span><br><span class="line">                <span class="comment">// 对于当前消费者，迭代所有 PEL 条目以发出 XCLAIM 协议</span></span><br><span class="line">                raxIterator ri_pel;</span><br><span class="line">                raxStart(&amp;ri_pel,consumer-&gt;pel);</span><br><span class="line">                raxSeek(&amp;ri_pel,<span class="string">&quot;^&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span>(raxNext(&amp;ri_pel)) &#123;</span><br><span class="line">                    streamNACK *nack = ri_pel.data;</span><br><span class="line">                    <span class="keyword">if</span> (rioWriteStreamPendingEntry(r,key,(<span class="keyword">char</span>*)ri.key, ri.key_len,consumer, ri_pel.key,nack) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                raxStop(&amp;ri_pel);</span><br><span class="line">            &#125;</span><br><span class="line">            raxStop(&amp;ri_cons);</span><br><span class="line">        &#125;</span><br><span class="line">        raxStop(&amp;ri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    streamIteratorStop(&amp;si);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-Module模块处理"><a href="#重写AOF-Module模块处理" class="headerlink" title="重写AOF-Module模块处理"></a>重写AOF-Module模块处理</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteModuleObject</span><span class="params">(rio *r, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    RedisModuleIO io;</span><br><span class="line">    moduleValue *mv = o-&gt;ptr;</span><br><span class="line">    moduleType *mt = mv-&gt;type;</span><br><span class="line">    moduleInitIOContext(io,mt,r,key);</span><br><span class="line">    mt-&gt;aof_rewrite(&amp;io,key,mv-&gt;value);</span><br><span class="line">    <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">        moduleFreeContext(io.ctx);</span><br><span class="line">        zfree(io.ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> io.error ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="重写AOF-差异处理"><a href="#重写AOF-差异处理" class="headerlink" title="重写AOF-差异处理"></a>重写AOF-差异处理</h3></div>
<p>子进程执行此函数, 将父进程积累的AOF差异文件读取到缓冲区中. 在AOF重写结束时处理这部分数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">aofReadDiffFromParent</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大多数 Linux 系统上的默认管道缓冲区大小</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">65536</span>];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread, total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将父进程的差异数据保存到AOF重写缓冲区中</span></span><br><span class="line">    <span class="keyword">while</span> ((nread = read(server.aof_pipe_read_data_from_parent,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);</span><br><span class="line">        total += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/11/Redis-AOF%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yangs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小花儿的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/11/Redis-AOF%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis-AOF持久化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-11 23:36:24" itemprop="dateCreated datePublished" datetime="2022-01-11T23:36:24+08:00">2022-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-09 14:32:40" itemprop="dateModified" datetime="2023-03-09T14:32:40+08:00">2023-03-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <div class="note success"><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3></div>

<p>该方法在AOF持久化时执行, 将数据从aof_buf缓冲区中写入到AOF文件中, 同时根据不同的同步刷盘策略进行同步到磁盘文件中</p>
<p>同步策略：<br>#define AOF_FSYNC_NO 0          // 由操作系统决定<br>#define AOF_FSYNC_ALWAYS 1      // 每次事件循环后刷盘<br>#define AOF_FSYNC_EVERYSEC 2    // 间隔1秒以上执行刷盘</p>
<p>当fsync策略为AOF_FSYNC_EVERYSEC时. 如果后台线程中有fsync在进行, 那么要延迟刷新<br>因为在Linux系统上write操作会被fsync阻塞.所以这里即使这里不延迟处理也会被系统的fsync阻塞住</p>
<div class="note success"><h3 id="写入AOF-文件写入"><a href="#写入AOF-文件写入" class="headerlink" title="写入AOF-文件写入"></a>写入AOF-文件写入</h3></div>
<p>检查是否需要在AOF缓冲区为空的情况下进行刷盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当AOF缓冲区没有数据时</span></span><br><span class="line"><span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在5.0以上版本新增的处理, 检查是否需要在AOF缓冲区为空的情况下进行刷盘</span></span><br><span class="line">    <span class="comment">// 当刷盘策略为AOF_FSYNC_EVERYSEC模式, 缓冲区有数据未刷盘, 当前时间已经超过1秒, 同时当前没有fsync在执行</span></span><br><span class="line">    <span class="comment">// 在AOF_FSYNC_EVERYSEC模式下, 只有在aof缓冲区不为空时才会调用fsync, 所以如果用户在一秒钟内调用fsync之前停止写命令, 页面缓存中的数据将无法及时刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; server.aof_fsync_offset != server.aof_current_size &amp;&amp; server.unixtime &gt; server.aof_last_fsync &amp;&amp; !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">        <span class="keyword">goto</span> try_fsync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AOF_FSYNC_EVERYSEC模式下, 需要检测是否有AOF同步事件在执行fsync操作, 如果有则要延迟处理此次数据写入, 除非延迟时间超过了2秒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当刷盘策略为AOF_FSYNC_EVERYSEC模式时, 调用函数判断BIO_AOF_FSYNC类型事件的待处理的数量是否等于0. 如果大于0则表示有AOF同步事件在执行</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">    sync_in_progress = aofFsyncInProgress();</span><br><span class="line"><span class="comment">// 当刷盘策略为AOF_FSYNC_EVERYSEC模式, 且指定入参为0</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">    <span class="comment">// 表示有AOF同步事件在执行fsync操作, 那么这里要判断是否进行延迟处理</span></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        <span class="comment">// 之前没有延迟处理, 此次是第一次碰到要延迟处理. 那么记录我们要延迟操作, 记录下当前时间, 此次操作直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">            server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 此前已经触发了延迟处理, 距离上次延迟处理的时间间隔还没超过2秒, 此次不处理, 直接返回继续等待</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此前已经触发了延迟处理, 且距离上次延迟处理的时间间隔已经超过2秒, 不能忍受, 直接进行写入操作</span></span><br><span class="line">        server.aof_delayed_fsync++;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正执行写入文件操作, 将aof_buf中的数据写入到AOF文件中, 同时返回写入成功的字节数. -1表示写入错误<br>同时记录一些日志信息, 用于对Redis的监控使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">    usleep(server.aof_flush_sleep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始监控一个事件, 设置当前时间, 和latencyEndMonitor方法组成一个监控, 监控AOF的写入操作时间</span></span><br><span class="line">latencyStartMonitor(latency);</span><br><span class="line"><span class="comment">// 真正执行将AOF缓冲区数据写入AOF文件(只是应用层面的写入, 系统级磁盘同步在后面)</span></span><br><span class="line">nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">latencyEndMonitor(latency);</span><br><span class="line"><span class="comment">// 记录一些时间, 用于监控</span></span><br><span class="line"><span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">&#125;</span><br><span class="line">latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"><span class="comment">// 我们执行了写入, 因此将推迟的刷新标记重置为零</span></span><br><span class="line">server.aof_flush_postponed_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>针对部分失败进行补救处理, 全部成功的状态变更</p>
<ol>
<li>当部分写入失败时, 需要尝试将写入的部分数据进行移除. 如果移除失败那么裁剪aof_buf中的数据. 要确保写入到AOF中的文件是正确的</li>
<li>AOF_FSYNC_ALWAYS模式下如果出现部分失败, 则无法进行错误处理. 直接退出程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当写入AOF文件的长度和AOF缓冲区长度不一致, 表示部分写入失败或者全部失败</span></span><br><span class="line"><span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制日志速率, 限制为每AOF_WRITE_LOG_ERROR_RATE秒写一次刷新错误日志</span></span><br><span class="line">    <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">        can_log = <span class="number">1</span>;</span><br><span class="line">        last_write_error_log = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次写入完全失败, 一点也没写进去</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断可以写日志</span></span><br><span class="line">        <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>, strerror(errno));</span><br><span class="line">            server.aof_last_write_errno = errno;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span><span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span><span class="string">&quot;expected=%lld)&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten, (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 尝试回退刚刚写入的不完整数据, 如果操作失败则记录日志</span></span><br><span class="line">        <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span><span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span><span class="string">&quot;to load the AOF the next time it starts.  &quot;</span><span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试从AOF文件中移除部分成功的数据, 成功后将写入状态置为-1</span></span><br><span class="line">            nwritten = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_write_errno = ENOSPC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是AOF_FSYNC_ALWAYS模式</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">// 当fsync策略为ALWAYS时, 因为给客户端的恢复已经在输出缓冲区中, 同时和请求方约定, 确认写入的数据已经同步到磁盘上, 无法进行恢复, 退出</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从失败的写入中恢复，将数据留在缓冲区中。 但是，只要错误条件未清除，就设置错误以停止接受写入。</span></span><br><span class="line">        server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是部分写入成功, 同时ftruncate函数也没有成功将这部分数据从AOF文件中清除. 那么裁剪AOF缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            server.aof_current_size += nwritten;</span><br><span class="line">            sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此次AOF写入失败了, 直接返回, 然后在下次调用此方法写入AOF数据时再次进行尝试</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此前AOF处于错误状态, 但是此次写入成功了. 则恢复为OK状态.表示AOF写入错误已经恢复了,可以继续写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">        server.aof_last_write_status = C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server.aof_current_size += nwritten;</span><br></pre></td></tr></table></figure>
<p>写入成功要清除aof_buf数据. 根据数据的多少决定是清空原空间还是重新申请空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断下当前的AOF缓冲区大小, 如果小于4000, 则清除缓冲区复用. </span></span><br><span class="line"><span class="comment">// 如果大于4000, 那么释放缓冲区重新申请新的缓冲区</span></span><br><span class="line"><span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">    sdsclear(server.aof_buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sdsfree(server.aof_buf);</span><br><span class="line">    server.aof_buf = sdsempty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="写入AOF-write系统函数"><a href="#写入AOF-write系统函数" class="headerlink" title="写入AOF-write系统函数"></a>写入AOF-write系统函数</h3></div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调用系统write函数写入数据</span></span><br><span class="line"><span class="comment">* write有写入限制, 不能一次将所有数据写入, 需要程序控制</span></span><br><span class="line"><span class="comment">* 正常情况下传入的len和这个函数的返回值应该一致, 不一致则可能发生写入失败仅有部分写入成功</span></span><br><span class="line"><span class="comment">* int fd             AOF文件描述符</span></span><br><span class="line"><span class="comment">* const char *buf    AOF缓冲区, 一个字符串</span></span><br><span class="line"><span class="comment">* size_t len         AOF缓冲区长度, 字符串长度</span></span><br><span class="line"><span class="comment">* 返回成功写入的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">aofWrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        nwritten = write(fd, buf, len);</span><br><span class="line">        <span class="comment">// 返回小于0, 表示写入失败了</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为系统中断导致写入失败, 则重试</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 说明I/O失败了返回已写入的字节数</span></span><br><span class="line">            <span class="keyword">return</span> totwritten ? totwritten : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新计算长度, write有写入限制不能一次全部写入, 需要控制偏移量, 进行循环写入</span></span><br><span class="line">        len -= nwritten;</span><br><span class="line">        buf += nwritten;</span><br><span class="line">        totwritten += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><h3 id="写入AOF-fsync同步磁盘"><a href="#写入AOF-fsync同步磁盘" class="headerlink" title="写入AOF-fsync同步磁盘"></a>写入AOF-fsync同步磁盘</h3></div>
<ol>
<li>如果是AOF_FSYNC_ALWAYS, 则直接执行fsync进行磁盘同步</li>
<li>如果是AOF_FSYNC_EVERYSEC, 则判断时间是否已经过了1秒. 然后放入队列中交由子线程消费队列执行刷盘任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">// 如果正在进行AOF重写操作, 并且有子进程在后台执行 I/O, 则不要fsync</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷盘策略为AOF_FSYNC_ALWAYS, 则进行fsync</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        <span class="comment">// redis_fsync被定义为Linux的fdatasync函数,避免刷新元数据.调用系统函数fsync进行刷盘</span></span><br><span class="line">        redis_fsync(server.aof_fd);</span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        <span class="comment">// 更新最后刷盘时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">        <span class="comment">// 如果刷盘策略为AOF_FSYNC_EVERYSEC, 则判断时间是否满足, 满足则进行fsync</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            <span class="comment">// redis提供了一个链表形式的队列, 主线程向队列中添加任务, 子线程阻塞等待读取任务, 并执行刷盘任务</span></span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yangs</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
